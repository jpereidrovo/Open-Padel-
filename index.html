<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Open Padel</title>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { margin: 0; background: #0b1020; color: #eef2ff; }
    a { color: inherit; }

    .appShell { display: grid; grid-template-columns: 270px 1fr; min-height: 100vh; }
    .sidebar {
      background: rgba(255,255,255,.05);
      border-right: 1px solid rgba(255,255,255,.12);
      padding: 14px;
      position: sticky;
      top: 0;
      height: 100vh;
      box-sizing: border-box;
    }
    .main { padding: 16px; box-sizing: border-box; }

    .brand { display:flex; gap:10px; align-items:center; margin-bottom: 14px; }
    .logo {
      width: 38px; height: 38px; border-radius: 12px;
      background: rgba(79,70,229,.35);
      border: 1px solid rgba(255,255,255,.18);
      display:flex; align-items:center; justify-content:center;
      font-weight: 900;
    }
    .brandTitle { line-height: 1.1; }
    .brandTitle b { display:block; }
    .brandTitle span { font-size: 12px; opacity: .75; }

    .nav { display: grid; gap: 8px; margin: 14px 0 18px; }
    .navBtn {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.20);
      color: #eef2ff;
      cursor: pointer;
      text-align: left;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      font-weight: 750;
    }
    .navBtn.active { background: rgba(79,70,229,.28); border-color: rgba(255,255,255,.22); }
    .navBtn .tag {
      font-size: 12px;
      opacity:.85;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.12);
      font-weight: 800;
      white-space:nowrap;
    }

    .sidebarCard {
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 12px;
      display:grid;
      gap:10px;
    }

    .row { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .row3 { display:grid; grid-template-columns: 1.2fr .8fr .8fr; gap: 10px; }
    .btns { display:flex; gap: 10px; flex-wrap: wrap; }
    button, input, select {
      box-sizing: border-box;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.25);
      color: #eef2ff;
      padding: 10px 12px;
      outline: none;
    }
    button { cursor: pointer; font-weight: 750; }
    button.primary { background: #4f46e5; border-color: rgba(255,255,255,.2); }
    button.ghost { background: transparent; }
    button.small { padding: 7px 10px; border-radius: 10px; width:auto; font-weight: 850; }
    button:disabled { opacity: .55; cursor: not-allowed; }

    label { display:block; font-size: 12px; opacity:.9; margin-bottom: 6px; }
    .hint { font-size: 12px; opacity: .85; line-height: 1.35; }
    .muted { opacity: .75; }
    .ok { color:#bbf7d0; }
    .warn { color:#fde68a; }
    .error { color:#fecaca; }
    .pill {
      display:inline-flex; gap:8px; align-items:center;
      padding: 6px 10px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      font-size: 12px;
      background: rgba(0,0,0,.12);
    }
    .card {
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 14px;
    }

    .table { display:grid; gap:8px; }
    .dbRow {
      display:grid;
      grid-template-columns: auto 1.25fr .55fr .55fr auto auto;
      gap:8px;
      align-items:center;
      padding:10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
    }
    input[type="checkbox"] { width: auto; transform: scale(1.12); }

    .dbRow input.nameInp, .dbRow select.sideSel, .dbRow input.ratingInp {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
    }
    .dbRow input.nameInp { font-weight: 850; }

    .badge {
      display:inline-flex; padding: 3px 8px;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 999px;
      font-size: 12px;
      opacity: .95;
      font-weight: 850;
      line-height: 1;
    }

    .split { display:flex; justify-content:space-between; align-items:baseline; gap:10px; flex-wrap:wrap; }
    .sectionTitle { margin: 0 0 10px; font-size: 16px; }

    .grid3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap: 14px; align-items:start; }
    .teamList { display:grid; gap:8px; }
    .teamItem {
      display:grid;
      grid-template-columns: 1fr auto auto;
      gap:10px;
      align-items:center;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
    }

    .list { display:grid; gap:10px; }
    .turn { border: 1px solid rgba(255,255,255,.14); border-radius: 14px; overflow:hidden; }
    .turn h3 {
      margin:0; padding: 10px 12px;
      background: rgba(255,255,255,.06);
      font-size: 14px;
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
    }
    .turn .content { padding: 12px; display:grid; gap:10px; }
    .court {
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.12);
      display:grid; gap:6px;
    }
    .scoreRow { display:grid; grid-template-columns: 1fr 160px; gap:10px; align-items:center; }
    .mini { font-size: 12px; opacity:.85; }

    .pairText { font-weight: 850; letter-spacing: .1px; }
    .pairText .badge { margin-left: 6px; }
    .pairSep { opacity:.85; font-weight: 900; }

    @media (max-width: 1100px){
      .appShell { grid-template-columns: 1fr; }
      .sidebar { position: relative; height: auto; }
      .grid3 { grid-template-columns: 1fr; }
    }

    @media print {
      body { background: white; color: black; }
      .sidebar, .noPrint { display:none !important; }
      .card { border: 1px solid #ddd; background: white; }
      .turn, .court { border: 1px solid #ddd; background: white; }
      .badge { border: 1px solid #aaa; }
    }
  </style>
</head>

<body>
<div class="appShell">
  <aside class="sidebar noPrint">
    <div class="brand">
      <div class="logo">OP</div>
      <div class="brandTitle">
        <b>Open Padel</b>
        <span>Base ‚Ä¢ Equipos ‚Ä¢ Turnos</span>
      </div>
    </div>

    <div class="sidebarCard" id="authCard">
      <div class="hint" id="authStatus">Cargando sesi√≥n‚Ä¶</div>
      <div class="btns">
        <button class="primary small" id="loginBtn">Google</button>
        <button class="ghost small" id="logoutBtn" style="display:none">Salir</button>
      </div>
    </div>

    <div class="nav" style="margin-top: 14px;">
      <button class="navBtn active" id="navBase">
        <span>üë§ Base de jugadores</span>
        <span class="tag" id="tagBase">0</span>
      </button>
      <button class="navBtn" id="navTeams">
        <span>üë• Equipos</span>
        <span class="tag" id="tagTeams">0/16</span>
      </button>
      <button class="navBtn" id="navTurns">
        <span>üéæ Turnos</span>
        <span class="tag" id="tagTurns">‚Äî</span>
      </button>
    </div>

    <div class="sidebarCard">
      <div class="hint">
        <b>Flujo recomendado</b><br/>
        1) En <b>Base</b> selecciona jugadores (pool).<br/>
        2) En <b>Equipos</b> arma A/B (manual o auto).<br/>
        3) En <b>Turnos</b> genera cruces y exporta.
      </div>
      <div class="pill" id="pillInfo">N: <b>16</b> ‚Ä¢ Canchas: <b>4</b></div>
    </div>
  </aside>

  <main class="main">
    <div id="appRoot" style="display:none;">
      <!-- BASE -->
      <section id="viewBase">
        <div class="card">
          <div class="split">
            <h2 class="sectionTitle">Base de jugadores</h2>
            <div class="pill">
              <span id="selCountText">0/16</span>
              <span class="muted" id="selSideText">D:0 R:0</span>
            </div>
          </div>

          <div class="row">
            <div>
              <label>Cantidad de jugadores a jugar</label>
              <select id="totalPlayers">
                <option value="4">4</option>
                <option value="8">8</option>
                <option value="12">12</option>
                <option value="16" selected>16</option>
                <option value="20">20</option>
                <option value="24">24</option>
              </select>
            </div>
            <div>
              <label>Estado de mix (D/R)</label>
              <div class="hint" id="selNeedText"></div>
            </div>
          </div>

          <div style="height:10px"></div>
          <div class="btns">
            <button class="ghost" id="clearSelection">Limpiar selecci√≥n</button>
            <button class="primary" id="goTeams">Ir a Equipos ‚Üí</button>
          </div>
        </div>

        <div style="height:14px"></div>

        <div class="card">
          <h2 class="sectionTitle">Agregar jugador</h2>
          <div class="row3">
            <div>
              <label>Nombre</label>
              <input id="dbName" placeholder="Ej: Juan" />
            </div>
            <div>
              <label>Lado</label>
              <select id="dbSide">
                <option value="D">Derecha (D)</option>
                <option value="R">Rev√©s (R)</option>
              </select>
            </div>
            <div>
              <label>Nivel (1‚Äì10)</label>
              <input id="dbRating" type="number" min="1" max="10" value="5" />
            </div>
          </div>

          <div style="height:10px"></div>
          <div class="btns">
            <button class="primary" id="dbAdd">Agregar</button>
          </div>

          <div id="dbStatus" class="hint" style="margin-top:10px;"></div>
        </div>

        <div style="height:14px"></div>

        <div class="card">
          <div class="split">
            <h2 class="sectionTitle">Lista (editar + seleccionar)</h2>
            <div class="hint muted" id="dbCount"></div>
          </div>

          <div class="row">
            <div>
              <label>Buscar</label>
              <input id="dbSearch" placeholder="Filtrar por nombre..." />
            </div>
            <div>
              <label>Ordenar</label>
              <select id="dbSort">
                <option value="name">Nombre</option>
                <option value="ratingDesc">Nivel (mayor‚Üímenor)</option>
                <option value="ratingAsc">Nivel (menor‚Üímayor)</option>
                <option value="side">Lado (D/R)</option>
              </select>
            </div>
          </div>

          <div style="height:12px"></div>
          <div class="table" id="dbList"></div>

          <div class="hint muted" style="margin-top:10px;">
            ‚úî Edita: nombre, D/R y nivel. ‚úî Selecciona con checkbox (respeta mix D/R).
          </div>
        </div>
      </section>

      <!-- TEAMS -->
      <section id="viewTeams" style="display:none;">
        <div class="card">
          <div class="split">
            <h2 class="sectionTitle">Equipos</h2>
            <div class="pill" id="teamsInfo">0/16 ‚Ä¢ D:0 R:0</div>
          </div>

          <div class="btns">
            <button class="primary" id="autoTeams">Autoarmar A/B (otra alternativa)</button>
            <button class="ghost" id="clearTeams">Limpiar Equipos</button>
            <button class="ghost" id="backBase">‚Üê Volver a Base</button>
            <button class="ghost" id="goTurns">Ir a Turnos ‚Üí</button>
          </div>

          <div id="teamsStatus" class="hint" style="margin-top:10px;"></div>

          <div style="height:10px"></div>
          <div class="pill" id="pillPlayers">N: <b>16</b></div>
          <div class="pill" id="pillCourts">Canchas/turno: <b>4</b></div>
        </div>

        <div style="height:14px"></div>

        <div class="grid3">
          <div class="card">
            <div class="split">
              <h2 class="sectionTitle">Pool</h2>
              <div class="hint muted">Mueve a A o B</div>
            </div>
            <div class="teamList" id="poolList"></div>
            <div id="poolStatus" class="hint" style="margin-top:10px;"></div>
          </div>

          <div class="card">
            <div class="split">
              <h2 class="sectionTitle">Equipo A</h2>
              <div class="hint muted" id="teamAInfo"></div>
            </div>
            <div class="teamList" id="teamAList"></div>
            <div style="height:10px"></div>
            <div class="btns">
              <button class="ghost" id="teamAClear">Vaciar A</button>
            </div>
            <div id="teamAStatus" class="hint"></div>
          </div>

          <div class="card">
            <div class="split">
              <h2 class="sectionTitle">Equipo B</h2>
              <div class="hint muted" id="teamBInfo"></div>
            </div>
            <div class="teamList" id="teamBList"></div>
            <div style="height:10px"></div>
            <div class="btns">
              <button class="ghost" id="teamBClear">Vaciar B</button>
            </div>
            <div id="teamBStatus" class="hint"></div>
          </div>
        </div>
      </section>

      <!-- TURNS -->
      <section id="viewTurns" style="display:none;">
        <div class="card">
          <div class="split">
            <h2 class="sectionTitle">Turnos</h2>
            <div class="pill" id="turnsInfo">Listo para generar</div>
          </div>

          <div class="row">
            <div>
              <label>No repetir parejas</label>
              <select id="noRepeatPairs">
                <option value="yes" selected>S√≠</option>
                <option value="no">No</option>
              </select>
            </div>
            <div>
              <label>Exportar</label>
              <select id="exportMode">
                <option value="csv">Excel (CSV)</option>
                <option value="pdf">PDF (Imprimir)</option>
              </select>
            </div>
          </div>

          <div style="height:10px"></div>
          <div class="btns">
            <button class="primary" id="gen">Generar turnos (otra alternativa)</button>
            <button class="ghost" id="export">Exportar</button>
            <button class="ghost" id="copy">Copiar</button>
            <button class="ghost" id="backTeams">‚Üê Volver a Equipos</button>
          </div>

          <div id="turnsStatus" class="hint" style="margin-top:10px;"></div>
          <div class="hint muted" style="margin-top:6px;">
            Puntos: Turno 1 = 1 ‚Ä¢ Turno 2 = 2 ‚Ä¢ Turno 3 = 3
          </div>
        </div>

        <div style="height:14px"></div>
        <div class="card">
          <h2 class="sectionTitle">Cruces</h2>
          <div id="out" class="list"></div>
          <div class="hint muted" style="margin-top:10px;">
            Puedes apretar ‚ÄúGenerar turnos‚Äù varias veces para obtener cruces diferentes.
          </div>
        </div>
      </section>
    </div>

    <div id="loggedOut" class="card" style="display:none;">
      <h2 class="sectionTitle">Inicia sesi√≥n</h2>
      <div class="hint">Usa el bot√≥n Google en la barra lateral.</div>
    </div>
  </main>
</div>

<script>
(() => {
  // =====================
  // Supabase config
  // =====================
  const SUPABASE_URL = "https://tuquyruyyizzccxrvafc.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1cXV5cnV5eWl6emNjeHJ2YWZjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3MTY5NjgsImV4cCI6MjA4MzI5Mjk2OH0.mTsLI_LQC9ccI7Yoc8UL7coGqQlab8NTp3ItFnX7nnE";

  const authStatusEl = document.getElementById("authStatus");
  const loginBtn = document.getElementById("loginBtn");
  const logoutBtn = document.getElementById("logoutBtn");
  const appRoot = document.getElementById("appRoot");
  const loggedOut = document.getElementById("loggedOut");

  if (!window.supabase || !window.supabase.createClient) {
    authStatusEl.textContent = "Error: no carg√≥ Supabase JS.";
    return;
  }
  const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  loginBtn.addEventListener("click", async () => {
    authStatusEl.textContent = "Abriendo Google‚Ä¶";
    const { error } = await sb.auth.signInWithOAuth({
      provider: "google",
      options: { redirectTo: window.location.origin + window.location.pathname }
    });
    if (error) authStatusEl.textContent = "Error login: " + error.message;
  });

  logoutBtn.addEventListener("click", async () => {
    await sb.auth.signOut();
    location.reload();
  });

  // =====================
  // App state
  // =====================
  const STORE_STATE = "open_padel_state_nav_v2";
  const STORE_SCORES = "open_padel_scores_nav_v2";
  const TURNS = 3;

  const $ = (id)=>document.getElementById(id);

  // Nav / Views
  const navBase = $("navBase");
  const navTeams = $("navTeams");
  const navTurns = $("navTurns");
  const viewBase = $("viewBase");
  const viewTeams = $("viewTeams");
  const viewTurns = $("viewTurns");

  const goTeams = $("goTeams");
  const goTurns = $("goTurns");
  const backBase = $("backBase");
  const backTeams = $("backTeams");

  // Badges
  const tagBase = $("tagBase");
  const tagTeams = $("tagTeams");
  const tagTurns = $("tagTurns");
  const pillInfo = $("pillInfo");

  // Base UI
  const totalPlayersEl = $("totalPlayers");
  const selCountText = $("selCountText");
  const selSideText = $("selSideText");
  const selNeedText = $("selNeedText");
  const clearSelectionBtn = $("clearSelection");

  const dbName = $("dbName");
  const dbSide = $("dbSide");
  const dbRating = $("dbRating");
  const dbAdd = $("dbAdd");
  const dbSearch = $("dbSearch");
  const dbSort = $("dbSort");
  const dbList = $("dbList");
  const dbCount = $("dbCount");
  const dbStatus = $("dbStatus");

  // Teams UI
  const teamsInfo = $("teamsInfo");
  const teamsStatus = $("teamsStatus");
  const poolList = $("poolList");
  const poolStatus = $("poolStatus");
  const teamAList = $("teamAList");
  const teamBList = $("teamBList");
  const teamAInfo = $("teamAInfo");
  const teamBInfo = $("teamBInfo");
  const teamAClear = $("teamAClear");
  const teamBClear = $("teamBClear");
  const teamAStatus = $("teamAStatus");
  const teamBStatus = $("teamBStatus");
  const autoTeamsBtn = $("autoTeams");
  const clearTeamsBtn = $("clearTeams");
  const pillPlayers = $("pillPlayers");
  const pillCourts = $("pillCourts");

  // Turns UI
  const turnsInfo = $("turnsInfo");
  const turnsStatus = $("turnsStatus");
  const noRepeatPairsEl = $("noRepeatPairs");
  const exportModeEl = $("exportMode");
  const genBtn = $("gen");
  const exportBtn = $("export");
  const copyBtn = $("copy");
  const out = $("out");

  /** @typedef {{id:string, name:string, side:'D'|'R', rating:number}} PlayerDB */
  /** @type {PlayerDB[]} */ let db = [];
  /** @type {{id:string}[]} */ let selected = []; // pool
  /** @type {{id:string}[]} */ let teamA = [];
  /** @type {{id:string}[]} */ let teamB = [];
  /** @type {Map<string,string>} */ let scores = new Map();

  // session-only ‚Äúmejor balance encontrado‚Äù
  let bestAuto = { diff: Infinity, sumA: 0, sumB: 0 };

  // =====================
  // Helpers
  // =====================
  function totalPlayers(){ return Number(totalPlayersEl.value); }
  function teamSize(){ return totalPlayers() / 2; }
  function courts(){ return totalPlayers() / 4; }
  function perTeamSide(){ return teamSize() / 2; }
  function totalPerSide(){ return totalPlayers() / 2; }

  function normalizeName(s){ return (s ?? "").trim().replace(/\s+/g," "); }
  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&","&amp;").replaceAll("<","&lt;")
      .replaceAll(">","&gt;").replaceAll('"',"&quot;");
  }
  function escapeHtmlAttr(s){ return escapeHtml(s).replaceAll("'","&#39;"); }

  function setStatus(el, msg, kind="") {
    const k = (kind==="error" ? "error" : kind==="ok" ? "ok" : kind==="warn" ? "warn" : "");
    el.className = "hint " + k;
    el.textContent = msg;
  }

  function byId(id){ return db.find(p => p.id === id) || null; }

  function countSide(refs, side) {
    return refs.reduce((acc, r) => {
      const p = byId(r.id);
      return acc + (p && p.side === side ? 1 : 0);
    }, 0);
  }

  function avgRating(refs) {
    const players = refs.map(r => byId(r.id)).filter(Boolean);
    if (!players.length) return 0;
    const sum = players.reduce((a,p)=>a+p.rating,0);
    return Math.round((sum / players.length) * 10) / 10;
  }

  function clearOutput(){ out.innerHTML = ""; }

  function saveLocalState() {
    try {
      localStorage.setItem(STORE_STATE, JSON.stringify({
        totalPlayers: totalPlayers(),
        selected, teamA, teamB,
        view: getView()
      }));
      localStorage.setItem(STORE_SCORES, JSON.stringify(Object.fromEntries(scores)));
    } catch {}
  }

  function loadLocalState() {
    try {
      const rawState = localStorage.getItem(STORE_STATE);
      const rawScores = localStorage.getItem(STORE_SCORES);

      if (rawState) {
        const st = JSON.parse(rawState) || {};
        const v = Number(st.totalPlayers);
        if ([4,8,12,16,20,24].includes(v)) totalPlayersEl.value = String(v);
        selected = Array.isArray(st.selected) ? st.selected : [];
        teamA = Array.isArray(st.teamA) ? st.teamA : [];
        teamB = Array.isArray(st.teamB) ? st.teamB : [];
        if (st.view === "teams") setView("teams");
        else if (st.view === "turns") setView("turns");
        else setView("base");
      } else {
        setView("base");
      }

      if (rawScores) {
        const o = JSON.parse(rawScores) || {};
        scores = new Map(Object.entries(o));
      }
    } catch {
      setView("base");
    }
  }

  // =====================
  // Navigation
  // =====================
  function setView(view){
    viewBase.style.display  = (view==="base")  ? "block" : "none";
    viewTeams.style.display = (view==="teams") ? "block" : "none";
    viewTurns.style.display = (view==="turns") ? "block" : "none";

    navBase.classList.toggle("active", view==="base");
    navTeams.classList.toggle("active", view==="teams");
    navTurns.classList.toggle("active", view==="turns");

    saveLocalState();
  }

  function getView(){
    if(viewTeams.style.display==="block") return "teams";
    if(viewTurns.style.display==="block") return "turns";
    return "base";
  }

  navBase.addEventListener("click", ()=>setView("base"));
  navTeams.addEventListener("click", ()=>setView("teams"));
  navTurns.addEventListener("click", ()=>setView("turns"));
  goTeams.addEventListener("click", ()=>setView("teams"));
  goTurns.addEventListener("click", ()=>setView("turns"));
  backBase.addEventListener("click", ()=>setView("base"));
  backTeams.addEventListener("click", ()=>setView("teams"));

  // =====================
  // Supabase DB functions
  // =====================
  async function loadDBFromSupabase() {
    const { data, error } = await sb.from("players").select("*").order("name");
    if (error) throw error;
    db = (data || []).map(x => ({ id: x.id, name: x.name, side: x.side, rating: x.rating }));
  }

  async function addPlayerToSupabase(name, side, rating) {
    const { error } = await sb.from("players").insert([{ name, side, rating }]);
    if (error) throw error;
  }

  async function updatePlayerInSupabase(id, patch) {
    const { error } = await sb.from("players").update(patch).eq("id", id);
    if (error) throw error;
  }

  // =====================
  // Score input + Winner + Totals
  // =====================
  function normalizeScoreInput(value) {
    const digits = String(value || "").replace(/\D/g, "").slice(0, 2);
    const a = digits[0] ?? "";
    const b = digits[1] ?? "";

    const aOk = a === "" ? "" : String(Math.max(0, Math.min(7, Number(a))));
    const bOk = b === "" ? "" : String(Math.max(0, Math.min(7, Number(b))));

    if (aOk && bOk) return `${aOk}-${bOk}`;
    if (aOk) return `${aOk}-`;
    return "";
  }

  function parseScore(value) {
    const digits = String(value || "").replace(/\D/g, "").slice(0, 2);
    if (digits.length < 2) return { valid: false, a: null, b: null };
    const a = Number(digits[0]);
    const b = Number(digits[1]);
    if (![a,b].every(n => Number.isInteger(n) && n >= 0 && n <= 7)) return { valid: false, a: null, b: null };
    return { valid: true, a, b };
  }

  function turnWeight(turnIndex) { return Number(turnIndex) || 0; } // 1..3

  function updateMatchWinnerUI(scoreId) {
    const el = document.getElementById(`win-${scoreId}`);
    if (!el) return;

    const raw = scores.get(scoreId) || "";
    const s = parseScore(raw);

    if (!s.valid) {
      el.textContent = "";
      el.className = "mini";
      return;
    }

    if (s.a === s.b) {
      el.textContent = "Empate (sin puntos)";
      el.className = "mini warn";
      return;
    }

    const winner = (s.a > s.b) ? "Equipo A" : "Equipo B";
    el.textContent = `Ganador: ${winner}`;
    el.className = "mini ok";
  }

  function updateTotalsUI() {
    let totalA = 0;
    let totalB = 0;

    // tambi√©n sacamos sumas por turno (mejora sugerida)
    const perTurn = Array.from({length: TURNS}, () => ({A:0, B:0}));

    for (let t = 1; t <= TURNS; t++) {
      const w = turnWeight(t);
      for (let c = 1; c <= courts(); c++) {
        const id = matchId(t, c);
        const raw = scores.get(id) || "";
        const s = parseScore(raw);
        if (!s.valid) continue;
        if (s.a === s.b) continue;

        if (s.a > s.b) { totalA += w; perTurn[t-1].A += w; }
        else { totalB += w; perTurn[t-1].B += w; }
      }
    }

    // No hay puntos a√∫n
    if (totalA === 0 && totalB === 0) {
      // Mant√©n mensaje base si equipos no est√°n completos
      if(teamA.length===teamSize() && teamB.length===teamSize()){
        turnsInfo.textContent = `A y B listos ‚Ä¢ Canchas: ${courts()} ‚Ä¢ Turnos: ${TURNS}`;
      } else {
        turnsInfo.textContent = `Completa equipos A/B para generar`;
      }
      return;
    }

    const turnStr = perTurn.map((x,i)=>`T${i+1}: A ${x.A} / B ${x.B}`).join(" ‚Ä¢ ");

    if (totalA === totalB) {
      turnsInfo.textContent = `Puntos: A ${totalA} ‚Ä¢ B ${totalB} ‚Äî Empate | ${turnStr}`;
    } else if (totalA > totalB) {
      turnsInfo.textContent = `Puntos: A ${totalA} ‚Ä¢ B ${totalB} ‚Äî Ganador global: Equipo A | ${turnStr}`;
    } else {
      turnsInfo.textContent = `Puntos: A ${totalA} ‚Ä¢ B ${totalB} ‚Äî Ganador global: Equipo B | ${turnStr}`;
    }
  }

  // =====================
  // Rendering
  // =====================
  function renderSidebarBadges(){
    tagBase.textContent = String(db.length);
    tagTeams.textContent = `${selected.length + teamA.length + teamB.length}/${totalPlayers()}`;
    tagTurns.textContent = out.children.length > 0 ? "‚úÖ" : "‚Äî";
    pillInfo.innerHTML = `N: <b>${totalPlayers()}</b> ‚Ä¢ Canchas: <b>${courts()}</b>`;
  }

  function renderPills(){
    pillPlayers.innerHTML = `N: <b>${totalPlayers()}</b>`;
    pillCourts.innerHTML = `Canchas/turno: <b>${courts()}</b>`;
  }

  function renderSelectionHeader(){
    const d = countSide(selected,"D");
    const r = countSide(selected,"R");
    const need = totalPerSide();

    selCountText.textContent = `${selected.length}/${totalPlayers()}`;
    selSideText.textContent = `D:${d} R:${r}`;

    let msg = `Requiere D:${need} R:${need}. `;
    const dDiff = need - d;
    const rDiff = need - r;

    if(selected.length < totalPlayers()){
      msg += `Faltan ${totalPlayers()-selected.length} en el pool`;
      if(dDiff>0 || rDiff>0) msg += ` | faltan D:${Math.max(0,dDiff)} R:${Math.max(0,rDiff)}`;
      if(dDiff<0 || rDiff<0) msg += ` | sobran D:${Math.max(0,-dDiff)} R:${Math.max(0,-rDiff)}`;
      selNeedText.className = "hint warn";
    } else {
      if(d===need && r===need){
        msg += "‚úÖ Selecci√≥n correcta (mix D/R OK).";
        selNeedText.className = "hint ok";
      } else {
        msg += `‚ùå Mix incorrecto: `;
        if(d!==need) msg += `D=${d} `;
        if(r!==need) msg += `R=${r} `;
        selNeedText.className = "hint error";
      }
    }
    selNeedText.textContent = msg;
  }

  function renderTeamsHeader(){
    const totalPicked = selected.length + teamA.length + teamB.length;
    const d = countSide(selected,"D")+countSide(teamA,"D")+countSide(teamB,"D");
    const r = countSide(selected,"R")+countSide(teamA,"R")+countSide(teamB,"R");
    teamsInfo.textContent = `${totalPicked}/${totalPlayers()} ‚Ä¢ D:${d} R:${r}`;

    if(teamA.length===teamSize() && teamB.length===teamSize()){
      // si ya hay puntos, updateTotalsUI lo reemplaza
      if(out.children.length===0){
        turnsInfo.textContent = `A y B listos ‚Ä¢ Canchas: ${courts()} ‚Ä¢ Turnos: ${TURNS}`;
      }
    } else {
      turnsInfo.textContent = `Completa equipos A/B para generar`;
    }
  }

  function renderDB(){
    const q = dbSearch.value.trim().toLowerCase();
    const sort = dbSort.value;

    let items = db.slice().filter(p => normalizeName(p.name).toLowerCase().includes(q));
    if (sort === "name") items.sort((a,b)=>normalizeName(a.name).localeCompare(normalizeName(b.name)));
    if (sort === "ratingDesc") items.sort((a,b)=>b.rating-a.rating || normalizeName(a.name).localeCompare(normalizeName(b.name)));
    if (sort === "ratingAsc") items.sort((a,b)=>a.rating-b.rating || normalizeName(a.name).localeCompare(normalizeName(b.name)));
    if (sort === "side") items.sort((a,b)=>a.side.localeCompare(b.side) || normalizeName(a.name).localeCompare(normalizeName(b.name)));

    dbCount.textContent = `${db.length} en base`;
    dbList.innerHTML = "";

    const maxSel = totalPlayers();
    const needPerSide = totalPerSide();

    for(const p of items){
      const isSel = selected.some(r=>r.id===p.id);
      const isInTeams = teamA.some(r=>r.id===p.id) || teamB.some(r=>r.id===p.id);

      const dNow = countSide(selected,"D");
      const rNow = countSide(selected,"R");
      const wouldBeD = p.side==="D" ? dNow + (isSel?0:1) : dNow;
      const wouldBeR = p.side==="R" ? rNow + (isSel?0:1) : rNow;
      const selFull = selected.length >= maxSel;

      const disablePick =
        isInTeams ||
        (!isSel && selFull) ||
        (!isSel && (wouldBeD > needPerSide || wouldBeR > needPerSide));

      const row = document.createElement("div");
      row.className = "dbRow";
      row.innerHTML = `
        <input type="checkbox" class="pickCb" data-id="${p.id}" ${isSel ? "checked":""} ${disablePick ? "disabled":""} />

        <div>
          <input class="nameInp" data-id="${p.id}" value="${escapeHtmlAttr(normalizeName(p.name))}" />
          <div class="mini muted">${isInTeams ? "En A/B" : (isSel ? "En pool" : "Disponible")}</div>
        </div>

        <select class="sideSel" data-id="${p.id}">
          <option value="D" ${p.side==="D" ? "selected":""}>D</option>
          <option value="R" ${p.side==="R" ? "selected":""}>R</option>
        </select>

        <input class="ratingInp" data-id="${p.id}" type="number" min="1" max="10" value="${p.rating}" />

        <button class="ghost small" data-act="toA" data-id="${p.id}" ${(!isSel || teamA.length>=teamSize()) ? "disabled":""}>‚Üí A</button>
        <button class="ghost small" data-act="toB" data-id="${p.id}" ${(!isSel || teamB.length>=teamSize()) ? "disabled":""}>‚Üí B</button>
      `;
      dbList.appendChild(row);
    }

    dbList.querySelectorAll("input.pickCb").forEach(cb=>{
      cb.addEventListener("change", ()=>{
        const id = cb.getAttribute("data-id");
        if(!id) return;

        const p = byId(id);
        if(!p) return;

        if(cb.checked){
          if(selected.length >= totalPlayers()){
            cb.checked = false;
            return setStatus(dbStatus, `Ya tienes ${totalPlayers()} seleccionados en el pool.`, "error");
          }
          if(teamA.some(r=>r.id===id) || teamB.some(r=>r.id===id)){
            cb.checked = false;
            return setStatus(dbStatus, "Ese jugador ya est√° en A/B.", "error");
          }
          const dNow = countSide(selected,"D");
          const rNow = countSide(selected,"R");
          const need = totalPerSide();
          if(p.side==="D" && dNow >= need){
            cb.checked = false;
            return setStatus(dbStatus, `Ya tienes ${need} Derecha (D) en el pool.`, "warn");
          }
          if(p.side==="R" && rNow >= need){
            cb.checked = false;
            return setStatus(dbStatus, `Ya tienes ${need} Rev√©s (R) en el pool.`, "warn");
          }
          selected.push({id});
        }else{
          selected = selected.filter(r=>r.id!==id);
          teamA = teamA.filter(r=>r.id!==id);
          teamB = teamB.filter(r=>r.id!==id);
        }

        // equipos/turnos pueden cambiar
        scores.clear();
        clearOutput();
        bestAuto = { diff: Infinity, sumA: 0, sumB: 0 };
        saveLocalState();
        render();
      });
    });

    dbList.querySelectorAll("input.nameInp").forEach(inp=>{
      const apply = async ()=>{
        const id = inp.getAttribute("data-id");
        if(!id) return;
        const original = byId(id);
        if(!original) return;

        const newName = normalizeName(inp.value);
        if(!newName){
          inp.value = normalizeName(original.name);
          return setStatus(dbStatus, "Nombre inv√°lido (vac√≠o).", "error");
        }
        const nlow = newName.toLowerCase();
        if(db.some(p => p.id!==id && normalizeName(p.name).toLowerCase() === nlow)){
          inp.value = normalizeName(original.name);
          return setStatus(dbStatus, "Ya existe otro jugador con ese nombre.", "error");
        }

        if(newName !== normalizeName(original.name)){
          try{
            await updatePlayerInSupabase(id, { name: newName });
            await loadDBFromSupabase();
            setStatus(dbStatus, "Nombre actualizado.", "ok");
            saveLocalState();
            render();
          }catch(e){
            inp.value = normalizeName(original.name);
            setStatus(dbStatus, (e?.message || String(e)), "error");
          }
        }
      };
      inp.addEventListener("blur", apply);
      inp.addEventListener("keydown", (e)=>{
        if(e.key === "Enter"){ e.preventDefault(); inp.blur(); }
      });
    });

    dbList.querySelectorAll("select.sideSel").forEach(sel=>{
      sel.addEventListener("change", async ()=>{
        const id = sel.getAttribute("data-id");
        if(!id) return;
        const v = sel.value.toUpperCase();
        if(v!=="D" && v!=="R") return;

        const isSel = selected.some(r=>r.id===id);
        if(isSel){
          const dNow = countSide(selected,"D");
          const rNow = countSide(selected,"R");
          const need = totalPerSide();
          const old = byId(id)?.side;

          const dSim = dNow - (old==="D" ? 1 : 0) + (v==="D" ? 1 : 0);
          const rSim = rNow - (old==="R" ? 1 : 0) + (v==="R" ? 1 : 0);

          if(dSim > need || rSim > need){
            sel.value = old || "D";
            return setStatus(dbStatus, `No se puede: excede el mix requerido (D:${need} R:${need}).`, "warn");
          }
        }

        try{
          await updatePlayerInSupabase(id, { side: v });
          await loadDBFromSupabase();
          setStatus(dbStatus, "Lado actualizado.", "ok");
          scores.clear();
          clearOutput();
          bestAuto = { diff: Infinity, sumA: 0, sumB: 0 };
          saveLocalState();
          render();
        }catch(e){
          const old = byId(id)?.side || "D";
          sel.value = old;
          setStatus(dbStatus, (e?.message || String(e)), "error");
        }
      });
    });

    dbList.querySelectorAll("input.ratingInp").forEach(inp=>{
      inp.addEventListener("change", async ()=>{
        const id = inp.getAttribute("data-id");
        if(!id) return;
        let n = Number(inp.value);
        if(!Number.isFinite(n)) n = 5;
        n = Math.max(1, Math.min(10, Math.round(n)));
        inp.value = String(n);

        try{
          await updatePlayerInSupabase(id, { rating: n });
          await loadDBFromSupabase();
          setStatus(dbStatus, "Nivel actualizado.", "ok");
          bestAuto = { diff: Infinity, sumA: 0, sumB: 0 };
          saveLocalState();
          render();
        }catch(e){
          setStatus(dbStatus, (e?.message || String(e)), "error");
        }
      });
    });

    dbList.querySelectorAll("button").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const act = btn.getAttribute("data-act");
        const id = btn.getAttribute("data-id");
        if(!id) return;
        if(act==="toA") moveSelectedToTeam(id, "A");
        if(act==="toB") moveSelectedToTeam(id, "B");
      });
    });
  }

  function renderPool(){
    poolList.innerHTML = "";
    const players = selected.map(r=>byId(r.id)).filter(Boolean);
    players.sort((a,b)=>a.side.localeCompare(b.side) || b.rating-a.rating || normalizeName(a.name).localeCompare(normalizeName(b.name)));

    for(const p of players){
      const item = document.createElement("div");
      item.className = "teamItem";
      item.innerHTML = `
        <div>
          <div><b>${escapeHtml(normalizeName(p.name))}</b> <span class="badge">${p.side}</span> <span class="badge">${p.rating}</span></div>
          <div class="mini muted">Pool</div>
        </div>
        <button class="ghost small" ${teamA.length>=teamSize() ? "disabled":""}>‚Üí A</button>
        <button class="ghost small" ${teamB.length>=teamSize() ? "disabled":""}>‚Üí B</button>
      `;
      const [btnA, btnB] = item.querySelectorAll("button");
      btnA.addEventListener("click", ()=>moveSelectedToTeam(p.id, "A"));
      btnB.addEventListener("click", ()=>moveSelectedToTeam(p.id, "B"));
      poolList.appendChild(item);
    }
  }

  function renderTeams(){
    function renderTeam(listEl, refs, label){
      listEl.innerHTML = "";
      const players = refs.map(r=>byId(r.id)).filter(Boolean);
      players.sort((a,b)=>a.side.localeCompare(b.side) || b.rating-a.rating || normalizeName(a.name).localeCompare(normalizeName(b.name)));

      for(const p of players){
        const item = document.createElement("div");
        item.className = "teamItem";
        item.innerHTML = `
          <div>
            <div><b>${escapeHtml(normalizeName(p.name))}</b> <span class="badge">${p.side}</span> <span class="badge">${p.rating}</span></div>
            <div class="mini muted">${label}</div>
          </div>
          <button class="ghost small">‚Üê Pool</button>
          <button class="ghost small">Quitar</button>
        `;

        const [backBtn, rmBtn] = item.querySelectorAll("button");
        backBtn.addEventListener("click", ()=>{
          if(!selected.some(r=>r.id===p.id)) selected.push({id:p.id});
          if(label==="Equipo A") teamA = teamA.filter(r=>r.id!==p.id);
          else teamB = teamB.filter(r=>r.id!==p.id);
          scores.clear(); clearOutput();
          bestAuto = { diff: Infinity, sumA: 0, sumB: 0 };
          saveLocalState(); render();
        });

        rmBtn.addEventListener("click", ()=>{
          selected = selected.filter(r=>r.id!==p.id);
          if(label==="Equipo A") teamA = teamA.filter(r=>r.id!==p.id);
          else teamB = teamB.filter(r=>r.id!==p.id);
          scores.clear(); clearOutput();
          bestAuto = { diff: Infinity, sumA: 0, sumB: 0 };
          saveLocalState(); render();
        });

        listEl.appendChild(item);
      }
    }

    renderTeam(teamAList, teamA, "Equipo A");
    renderTeam(teamBList, teamB, "Equipo B");

    teamAInfo.textContent = `${teamA.length}/${teamSize()} ‚Ä¢ D:${countSide(teamA,"D")} R:${countSide(teamA,"R")} ‚Ä¢ prom:${avgRating(teamA)}`;
    teamBInfo.textContent = `${teamB.length}/${teamSize()} ‚Ä¢ D:${countSide(teamB,"D")} R:${countSide(teamB,"R")} ‚Ä¢ prom:${avgRating(teamB)}`;
  }

  function render(){
    renderPills();
    renderSelectionHeader();
    renderTeamsHeader();
    renderDB();
    renderPool();
    renderTeams();
    renderSidebarBadges();
    updateTotalsUI();
  }

  // =====================
  // Actions
  // =====================
  function moveSelectedToTeam(id, team){
    if(!selected.some(r=>r.id===id)) return setStatus(poolStatus, "Ese jugador no est√° en el pool.", "error");
    if(team==="A" && teamA.length>=teamSize()) return setStatus(teamAStatus, `A ya tiene ${teamSize()}.`, "error");
    if(team==="B" && teamB.length>=teamSize()) return setStatus(teamBStatus, `B ya tiene ${teamSize()}.`, "error");

    selected = selected.filter(r=>r.id!==id);

    if(team==="A"){
      if(!teamA.some(r=>r.id===id)) teamA.push({id});
      setStatus(teamAStatus, "Agregado a A.", "ok");
    } else {
      if(!teamB.some(r=>r.id===id)) teamB.push({id});
      setStatus(teamBStatus, "Agregado a B.", "ok");
    }

    scores.clear();
    clearOutput();
    bestAuto = { diff: Infinity, sumA: 0, sumB: 0 };
    saveLocalState();
    render();
  }

  function validateSelectedOrThrow(){
    const total = selected.length + teamA.length + teamB.length;
    if(total !== totalPlayers()){
      throw new Error(`Debes tener exactamente ${totalPlayers()} jugadores (Pool + A + B).`);
    }
    const need = totalPerSide();
    const d = countSide(selected,"D") + countSide(teamA,"D") + countSide(teamB,"D");
    const r = countSide(selected,"R") + countSide(teamA,"R") + countSide(teamB,"R");
    if(d !== need || r !== need){
      throw new Error(`Mix inv√°lido: requiere D:${need} R:${need} (tienes D:${d} R:${r}).`);
    }
  }

  function validateTeamsOrThrow(){
    if(teamA.length !== teamSize()) throw new Error(`Equipo A debe tener ${teamSize()} jugadores.`);
    if(teamB.length !== teamSize()) throw new Error(`Equipo B debe tener ${teamSize()} jugadores.`);
    if(countSide(teamA,"D") !== perTeamSide() || countSide(teamA,"R") !== perTeamSide())
      throw new Error(`Equipo A debe tener ${perTeamSide()}D y ${perTeamSide()}R.`);
    if(countSide(teamB,"D") !== perTeamSide() || countSide(teamB,"R") !== perTeamSide())
      throw new Error(`Equipo B debe tener ${perTeamSide()}D y ${perTeamSide()}R.`);
  }

  // =====================
  // Turn formatting with badges (no rating)
  // =====================
  function playerHtml(p){
    return `<span class="pName">${escapeHtml(normalizeName(p.name))}</span> <span class="badge">${escapeHtml(p.side)}</span>`;
  }
  function pairHtml(pair){
    return `${playerHtml(pair[0])} <span class="pairSep">+</span> ${playerHtml(pair[1])}`;
  }
  function pairText(pair){
    const a = `${normalizeName(pair[0].name)} (${pair[0].side})`;
    const b = `${normalizeName(pair[1].name)} (${pair[1].side})`;
    return `${a} + ${b}`;
  }

  // =====================
  // AUTOARMADO (din√°mico)
  // =====================
  function autoBuildTeamsBalancedFromSelected(){
    validateSelectedOrThrow();

    const allIds = new Set([
      ...selected.map(r=>r.id),
      ...teamA.map(r=>r.id),
      ...teamB.map(r=>r.id),
    ]);

    const players = [...allIds].map(id=>byId(id)).filter(Boolean);
    const needPerSide = totalPerSide();
    const needPerTeamSide = perTeamSide();

    const Ds = players.filter(p=>p.side==="D").slice().sort((a,b)=>b.rating-a.rating);
    const Rs = players.filter(p=>p.side==="R").slice().sort((a,b)=>b.rating-a.rating);

    if(Ds.length !== needPerSide || Rs.length !== needPerSide){
      throw new Error(`Los ${totalPlayers()} seleccionados deben tener ${needPerSide}D y ${needPerSide}R.`);
    }

    function jitterSort(arr){
      return arr
        .map(p => ({p, k: p.rating + (Math.random()*0.8 - 0.4)}))
        .sort((a,b)=>b.k-a.k)
        .map(x=>x.p);
    }

    const DsJ = jitterSort(Ds);
    const RsJ = jitterSort(Rs);

    const A=[], B=[];
    let sumA=0, sumB=0;
    let aD=0,aR=0,bD=0,bR=0;

    function canAdd(team, p){
      if(team==="A"){
        if(p.side==="D") return aD < needPerTeamSide;
        return aR < needPerTeamSide;
      } else {
        if(p.side==="D") return bD < needPerTeamSide;
        return bR < needPerTeamSide;
      }
    }
    function add(team, p){
      if(team==="A"){
        A.push(p); sumA += p.rating;
        if(p.side==="D") aD++; else aR++;
      } else {
        B.push(p); sumB += p.rating;
        if(p.side==="D") bD++; else bR++;
      }
    }

    // seed top 2 de cada lado en equipos diferentes
    add("A", DsJ[0]); add("B", DsJ[1]);
    add("A", RsJ[0]); add("B", RsJ[1]);

    const restD = DsJ.slice(2);
    const restR = RsJ.slice(2);

    function shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function greedyFill(list){
      const L = shuffle(list.slice());
      for(const p of L){
        const okA = canAdd("A", p);
        const okB = canAdd("B", p);

        if(!okA && !okB) throw new Error("No hay cupo en A/B (revisa selecci√≥n).");
        if(okA && !okB) { add("A", p); continue; }
        if(!okA && okB) { add("B", p); continue; }

        const diffIfA = Math.abs((sumA + p.rating) - sumB);
        const diffIfB = Math.abs(sumA - (sumB + p.rating));
        if(diffIfA < diffIfB) add("A", p);
        else if(diffIfB < diffIfA) add("B", p);
        else { if(Math.random()<0.5) add("A", p); else add("B", p); }
      }
    }

    greedyFill(restD);
    greedyFill(restR);

    function improveSwaps(side){
      let improved = true;
      let loops = 0;
      while(improved && loops < 300){
        loops++;
        improved = false;
        const aList = A.filter(x=>x.side===side);
        const bList = B.filter(x=>x.side===side);
        const baseDiff = Math.abs(sumA - sumB);

        shuffle(aList);
        shuffle(bList);

        for(const pa of aList){
          for(const pb of bList){
            const newSumA = sumA - pa.rating + pb.rating;
            const newSumB = sumB - pb.rating + pa.rating;
            const newDiff = Math.abs(newSumA - newSumB);
            if(newDiff < baseDiff){
              const ia = A.findIndex(x=>x.id===pa.id);
              const ib = B.findIndex(x=>x.id===pb.id);
              A[ia] = pb; B[ib] = pa;
              sumA = newSumA; sumB = newSumB;
              improved = true;
              break;
            }
          }
          if(improved) break;
        }
      }
    }
    improveSwaps("D");
    improveSwaps("R");

    teamA = A.map(p=>({id:p.id}));
    teamB = B.map(p=>({id:p.id}));
    selected = [];

    // cambiar equipos => reset turnos (para no mezclar)
    scores.clear();
    clearOutput();
    saveLocalState();
    render();

    const avgA = sumA / A.length;
    const avgB = sumB / B.length;
    const diff = Math.abs(avgA - avgB);

    if(diff < bestAuto.diff){
      bestAuto = { diff, sumA, sumB };
    }

    const fmt = (x)=>Math.round(x*100)/100;
    const kind = diff<=0.2 ? "ok" : (diff<=0.5 ? "warn" : "error");

    setStatus(
      teamsStatus,
      `‚úÖ Nueva alternativa: prom A=${fmt(avgA)} ‚Ä¢ prom B=${fmt(avgB)} ‚Ä¢ Œî=${fmt(diff)} | Mejor sesi√≥n: Œî=${fmt(bestAuto.diff)}`,
      kind
    );
  }

  // =====================
  // Turnos generation (din√°mico)
  // =====================
  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  function pairKey(a,b){ return [a.id,b.id].sort().join("||"); }
  function matchId(turn, court){ return `T${turn}-C${court}`; }

  function buildPairs(teamRefs, usedPairs){
    const players = teamRefs.map(r=>byId(r.id)).filter(Boolean);
    const rights = shuffle(players.filter(p=>p.side==="D").slice());
    const lefts  = players.filter(p=>p.side==="R").slice();
    if(rights.length !== lefts.length) return null;

    const result = [];
    function backtrack(i, remainingLefts){
      if(i===rights.length) return true;
      const r = rights[i];
      const idxs = shuffle([...Array(remainingLefts.length).keys()]);
      for(const j of idxs){
        const l = remainingLefts[j];
        const k = pairKey(r,l);
        if(usedPairs.has(k)) continue;

        result.push([r,l]);
        const next = remainingLefts.slice(0,j).concat(remainingLefts.slice(j+1));
        if(backtrack(i+1,next)) return true;
        result.pop();
      }
      return false;
    }
    return backtrack(0,lefts) ? result : null;
  }

  function addTurnUI(turnIndex, matches){
    const wrap = document.createElement("div");
    wrap.className = "turn";

    const h = document.createElement("h3");
    h.innerHTML = `<span>Turno ${turnIndex}</span><span class="mini muted">${courts()} canchas ‚Ä¢ Valor: ${turnWeight(turnIndex)} pt</span>`;

    const content = document.createElement("div");
    content.className = "content";

    matches.forEach((m, idx)=>{
      const courtNum = idx+1;
      const id = matchId(turnIndex, courtNum);
      const existing = scores.get(id) || "";

      const div = document.createElement("div");
      div.className = "court";
      div.innerHTML = `
        <div class="muted"><b>Cancha ${courtNum}</b></div>

        <div class="pairText" data-plain="${escapeHtmlAttr(pairText(m.a))}">
          <b>Equipo A:</b> ${pairHtml(m.a)}
        </div>

        <div class="pairText" data-plain="${escapeHtmlAttr(pairText(m.b))}">
          <b>Equipo B:</b> ${pairHtml(m.b)}
        </div>

        <div class="scoreRow">
          <div>
            <div class="mini muted">Marcador (1 set): escribe ‚Äú63‚Äù ‚Üí ‚Äú6-3‚Äù (0‚Äì7)</div>
            <div class="mini" id="win-${id}"></div>
          </div>
          <input
            data-score-id="${id}"
            inputmode="numeric"
            autocomplete="off"
            placeholder="Ej: 63"
            value="${escapeHtmlAttr(existing)}"
          />
        </div>
      `;
      content.appendChild(div);
    });

    wrap.appendChild(h);
    wrap.appendChild(content);
    out.appendChild(wrap);

    // Inputs: formato + winner + totals
    out.querySelectorAll("input[data-score-id]").forEach(inp=>{
      // Guardamos el valor anterior (para backspace fluido)
      inp.addEventListener("keydown", (e)=>{
        inp._prev = inp.value;
        inp._prevSelStart = inp.selectionStart;
      });

      inp.addEventListener("input", ()=>{
        const key = inp.getAttribute("data-score-id");
        if(!key) return;

        const prev = inp._prev || "";
        const prevDigits = prev.replace(/\D/g,"");
        const curDigits = String(inp.value||"").replace(/\D/g,"");
        const isDeleting = curDigits.length < prevDigits.length;

        // Si est√° borrando y queda "6-" (1 d√≠gito), permite borrar completamente si insiste
        let formatted = normalizeScoreInput(inp.value);
        if (isDeleting && formatted.endsWith("-") && formatted.length===2 && (curDigits.length===0 || curDigits.length===1)) {
          // Si el usuario borr√≥ hasta 1 d√≠gito, mantenemos "6-" pero permite borrar una vez m√°s
          // (si el input ya viene vac√≠o, lo dejamos vac√≠o)
          if (curDigits.length===0) formatted = "";
        }

        inp.value = formatted;
        scores.set(key, formatted);

        updateMatchWinnerUI(key);
        updateTotalsUI();
        saveLocalState();
      });

      // Render inicial del ganador si ya hab√≠a score guardado
      const key = inp.getAttribute("data-score-id");
      if(key) updateMatchWinnerUI(key);
    });

    updateTotalsUI();
  }

  function generateTurns(){
    validateSelectedOrThrow();
    validateTeamsOrThrow();

    const avoidRepeatPairs = noRepeatPairsEl.value === "yes";
    const usedPairsA = new Set();
    const usedPairsB = new Set();

    clearOutput();

    for(let t=1;t<=TURNS;t++){
      let ok=false;
      const maxTries=15000;

      for(let attempt=0;attempt<maxTries;attempt++){
        const pairsA = buildPairs(teamA, avoidRepeatPairs ? usedPairsA : new Set());
        if(!pairsA) continue;
        const pairsB = buildPairs(teamB, avoidRepeatPairs ? usedPairsB : new Set());
        if(!pairsB) continue;

        shuffle(pairsA); shuffle(pairsB);

        const matches=[];
        for(let i=0;i<courts();i++) matches.push({a:pairsA[i], b:pairsB[i]});

        if(avoidRepeatPairs){
          for(const m of matches){
            usedPairsA.add(pairKey(m.a[0], m.a[1]));
            usedPairsB.add(pairKey(m.b[0], m.b[1]));
          }
        }

        addTurnUI(t, matches);
        ok=true;
        break;
      }

      if(!ok) throw new Error(`No pude generar el turno ${t} sin repetir parejas. Prueba ‚ÄúNo‚Äù o reintenta.`);
    }

    // refresca UI por si hab√≠a scores guardados
    for (let t = 1; t <= TURNS; t++) {
      for (let c = 1; c <= courts(); c++) {
        updateMatchWinnerUI(matchId(t, c));
      }
    }
    updateTotalsUI();
  }

  // Export
  function exportCSV(){
    const rows=[];
    rows.push(["Turno","Cancha","Pareja A","Pareja B","Marcador","Ganador","Puntos A","Puntos B"].join(","));

    for(let t=1;t<=TURNS;t++){
      const w = turnWeight(t);
      for(let c=1;c<=courts();c++){
        const id = matchId(t,c);
        const raw = scores.get(id)||"";
        const score = raw.replaceAll('"','""');

        const s = parseScore(raw);
        let winner = "";
        let ptsA = 0, ptsB = 0;
        if(s.valid && s.a !== s.b){
          winner = (s.a > s.b) ? "Equipo A" : "Equipo B";
          if(s.a > s.b) ptsA = w; else ptsB = w;
        } else if (s.valid && s.a === s.b){
          winner = "Empate";
        }

        // leer texto limpio de parejas desde DOM
        const turnDiv = [...document.querySelectorAll(".turn")].find(x => x.querySelector("h3")?.innerText.includes(`Turno ${t}`));
        let pairA="", pairB="";
        if(turnDiv){
          const courtDiv = [...turnDiv.querySelectorAll(".court")][c-1];
          if(courtDiv){
            const pairLines = courtDiv.querySelectorAll(".pairText");
            pairA = (pairLines[0]?.getAttribute("data-plain") || "").replaceAll('"','""');
            pairB = (pairLines[1]?.getAttribute("data-plain") || "").replaceAll('"','""');
          }
        }

        rows.push([t,c,`"${pairA}"`,`"${pairB}"`,`"${score}"`,`"${winner}"`,ptsA,ptsB].join(","));
      }
    }

    const csv = rows.join("\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "open_padel_turnos.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
  function exportPDF(){ window.print(); }

  // =====================
  // Events
  // =====================
  totalPlayersEl.addEventListener("change", ()=>{
    selected = [];
    teamA = [];
    teamB = [];
    scores.clear();
    clearOutput();
    bestAuto = { diff: Infinity, sumA: 0, sumB: 0 };
    saveLocalState();
    render();
    setStatus(dbStatus, `Listo: selecciona ${totalPlayers()} jugadores (D:${totalPerSide()} R:${totalPerSide()}).`, "ok");
  });

  clearSelectionBtn.addEventListener("click", ()=>{
    selected = [];
    teamA = [];
    teamB = [];
    scores.clear();
    clearOutput();
    bestAuto = { diff: Infinity, sumA: 0, sumB: 0 };
    saveLocalState();
    render();
    setStatus(dbStatus, "Selecci√≥n limpia.", "ok");
  });

  dbAdd.addEventListener("click", async ()=>{
    const name = normalizeName(dbName.value);
    const side = dbSide.value;
    const ratingRaw = Number(dbRating.value);
    const rating = Math.max(1, Math.min(10, Math.round(ratingRaw)));

    if(!name) return setStatus(dbStatus, "Escribe un nombre.", "error");
    if(db.some(p => normalizeName(p.name).toLowerCase() === name.toLowerCase()))
      return setStatus(dbStatus, "Ese nombre ya existe.", "error");
    if(!Number.isFinite(ratingRaw)) return setStatus(dbStatus, "Nivel inv√°lido.", "error");

    try{
      await addPlayerToSupabase(name, side, rating);
      dbName.value = "";
      dbRating.value = "5";
      await loadDBFromSupabase();
      render();
      setStatus(dbStatus, "Jugador agregado.", "ok");
    }catch(e){
      setStatus(dbStatus, (e?.message || String(e)), "error");
    }
  });

  dbSearch.addEventListener("input", ()=>renderDB());
  dbSort.addEventListener("change", ()=>renderDB());

  teamAClear.addEventListener("click", ()=>{
    teamA.forEach(r=>{ if(!selected.some(x=>x.id===r.id)) selected.push({id:r.id}); });
    teamA=[];
    scores.clear(); clearOutput();
    bestAuto = { diff: Infinity, sumA: 0, sumB: 0 };
    saveLocalState(); render();
    setStatus(teamAStatus, "A vac√≠o (devuelto al pool).", "ok");
  });

  teamBClear.addEventListener("click", ()=>{
    teamB.forEach(r=>{ if(!selected.some(x=>x.id===r.id)) selected.push({id:r.id}); });
    teamB=[];
    scores.clear(); clearOutput();
    bestAuto = { diff: Infinity, sumA: 0, sumB: 0 };
    saveLocalState(); render();
    setStatus(teamBStatus, "B vac√≠o (devuelto al pool).", "ok");
  });

  autoTeamsBtn.addEventListener("click", ()=>{
    try{
      autoBuildTeamsBalancedFromSelected();
    }catch(e){
      setStatus(teamsStatus, e.message || String(e), "error");
    }
  });

  clearTeamsBtn.addEventListener("click", ()=>{
    [...teamA, ...teamB].forEach(r => { if(!selected.some(x=>x.id===r.id)) selected.push({id:r.id}); });
    teamA=[]; teamB=[];
    scores.clear(); clearOutput();
    bestAuto = { diff: Infinity, sumA: 0, sumB: 0 };
    saveLocalState(); render();
    setStatus(teamsStatus, "Equipos limpiados (todo volvi√≥ al pool).", "ok");
  });

  genBtn.addEventListener("click", ()=>{
    try{
      generateTurns();
      setStatus(turnsStatus, "‚úÖ Turnos generados (nueva alternativa).", "ok");
      saveLocalState();
      renderSidebarBadges();
    }catch(e){
      setStatus(turnsStatus, e.message || String(e), "error");
    }
  });

  exportBtn.addEventListener("click", ()=>{
    if(!out.innerText.trim()) return setStatus(turnsStatus, "Primero genera los turnos.", "error");
    if(exportModeEl.value==="csv") exportCSV();
    else exportPDF();
    setStatus(turnsStatus, "Exportaci√≥n iniciada.", "ok");
  });

  copyBtn.addEventListener("click", async ()=>{
    const lines = [];
    document.querySelectorAll(".turn").forEach(turnDiv=>{
      const title = turnDiv.querySelector("h3")?.innerText?.trim() || "";
      lines.push(title);

      turnDiv.querySelectorAll(".court").forEach((cDiv, idx)=>{
        const cancha = `Cancha ${idx+1}`;
        const pairs = cDiv.querySelectorAll(".pairText");
        const a = pairs[0]?.getAttribute("data-plain") || "";
        const b = pairs[1]?.getAttribute("data-plain") || "";
        const scoreInp = cDiv.querySelector("input[data-score-id]");
        const raw = scoreInp?.value?.trim() || "";
        const s = parseScore(raw);
        let winner = "";
        if(s.valid && s.a !== s.b) winner = (s.a > s.b) ? "Ganador A" : "Ganador B";
        else if(s.valid && s.a === s.b) winner = "Empate";
        lines.push(`${cancha}: A ${a} vs B ${b}${raw ? " | " + raw : ""}${winner ? " | " + winner : ""}`);
      });
      lines.push("");
    });

    const text = lines.join("\n").trim();
    if(!text) return setStatus(turnsStatus, "No hay resultado para copiar.", "error");
    try{
      await navigator.clipboard.writeText(text);
      setStatus(turnsStatus, "Copiado ‚úÖ (texto limpio)", "ok");
    }catch{
      setStatus(turnsStatus, "No se pudo copiar. Copia manualmente.", "error");
    }
  });

  // =====================
  // Init / Auth
  // =====================
  async function initAfterLogin(){
    loadLocalState();
    await loadDBFromSupabase();

    const ids = new Set(db.map(p=>p.id));
    selected = selected.filter(r=>ids.has(r.id));
    teamA = teamA.filter(r=>ids.has(r.id));
    teamB = teamB.filter(r=>ids.has(r.id));

    render();
    setStatus(dbStatus, "Listo: selecciona jugadores en Base.", "ok");
    setStatus(teamsStatus, "Arma A/B manual o usa Autoarmar (puedes apretar varias veces).", "ok");
    setStatus(turnsStatus, "Genera turnos cuando A/B est√©n completos.", "ok");

    // si hay scores guardados, refresca
    setTimeout(()=>{
      for (let t = 1; t <= TURNS; t++) {
        for (let c = 1; c <= courts(); c++) {
          updateMatchWinnerUI(matchId(t, c));
        }
      }
      updateTotalsUI();
    }, 0);
  }

  async function checkSession(){
    try{
      const { data, error } = await sb.auth.getSession();
      if(error) throw error;

      if(data.session){
        authStatusEl.textContent = "Sesi√≥n iniciada ‚úÖ";
        loginBtn.style.display = "none";
        logoutBtn.style.display = "inline-block";
        appRoot.style.display = "block";
        loggedOut.style.display = "none";
        await initAfterLogin();
      }else{
        authStatusEl.textContent = "Debes iniciar sesi√≥n";
        loginBtn.style.display = "inline-block";
        logoutBtn.style.display = "none";
        appRoot.style.display = "none";
        loggedOut.style.display = "block";
      }
    }catch(e){
      authStatusEl.textContent = "Error sesi√≥n: " + (e?.message || e);
      appRoot.style.display = "none";
      loggedOut.style.display = "block";
    }
  }

  sb.auth.onAuthStateChange((_event, session) => {
    if(session){
      checkSession();
    }
  });

  checkSession();
})();
</script>
</body>
</html>
